"""
VPBank K-MULT - Endpoint Wrapper Tools
Wraps existing API endpoints as Strands tools for supervisor agent
"""

from strands import tool
import asyncio
import logging
import io
from typing import Dict, Any, Optional
from fastapi import UploadFile
from datetime import datetime
from uuid import uuid4

logger = logging.getLogger(__name__)

@tool
def compliance_document_tool(query: str, file_data: Optional[Dict[str, Any]] = None) -> str:
    """
    Compliance document validation tool - wraps /compliance/document endpoint
    Preserves EXACT logic from compliance_routes.py
    """
    try:
        logger.info(f"üîß [COMPLIANCE_TOOL] Processing: {query[:100]}...")
        
        if file_data and file_data.get('raw_bytes'):
            # Import EXACT endpoint function
            from app.mutil_agent.routes.v1.compliance_routes import validate_document_file
            
            try:
                # Create UploadFile object - EXACT same as endpoint expects
                file_obj = UploadFile(
                    filename=file_data.get('filename', 'document.pdf'),
                    file=io.BytesIO(file_data.get('raw_bytes')),
                    size=len(file_data.get('raw_bytes', b'')),
                    headers={"content-type": file_data.get('content_type', 'application/pdf')}
                )
                
                # Reset file pointer
                file_obj.file.seek(0)
                
                # Call EXACT endpoint function with EXACT parameters
                async def call_endpoint():
                    return await validate_document_file(
                        file=file_obj,
                        document_type=None  # Auto-detect as in endpoint
                    )
                
                # Execute with proper async handling
                try:
                    result = asyncio.run(call_endpoint())
                except RuntimeError as e:
                    if "cannot be called from a running event loop" in str(e):
                        import concurrent.futures
                        def run_in_thread():
                            return asyncio.run(call_endpoint())
                        with concurrent.futures.ThreadPoolExecutor() as executor:
                            future = executor.submit(run_in_thread)
                            result = future.result(timeout=30)
                    else:
                        raise e
                
                # Format response using EXACT endpoint result structure
                if result and isinstance(result, dict):
                    data = result
                    
                    response = f"""‚öñÔ∏è **Ki·ªÉm tra tu√¢n th·ªß - VPBank K-MULT**

**üìÑ T√†i li·ªáu:** {file_data.get('filename', 'Unknown')}
**üìä Lo·∫°i t√†i li·ªáu:** {data.get('document_type', 'Unknown')}
**‚úÖ Tr·∫°ng th√°i:** {data.get('compliance_status', 'UNKNOWN')}
**üéØ ƒê·ªô tin c·∫≠y:** {data.get('confidence_score', 0):.1%}

**üìã Ph√¢n t√≠ch:**"""
                    
                    # Add document analysis
                    doc_analysis = data.get('document_analysis', {})
                    if doc_analysis:
                        category = doc_analysis.get('document_category', {})
                        if category.get('business_purpose'):
                            response += f"\n‚Ä¢ **M·ª•c ƒë√≠ch:** {category['business_purpose']}"
                    
                    # Add violations
                    response += "\n\n**‚ö†Ô∏è Vi ph·∫°m:**"
                    violations = data.get('violations', [])
                    if violations:
                        for i, v in enumerate(violations[:5], 1):
                            response += f"\n{i}. **{v.get('type', 'Unknown')}**: {v.get('description', 'N/A')}"
                    else:
                        response += "\n‚úÖ Kh√¥ng ph√°t hi·ªán vi ph·∫°m"
                    
                    # Add recommendations
                    response += "\n\n**üí° Khuy·∫øn ngh·ªã:**"
                    recommendations = data.get('recommendations', [])
                    if recommendations:
                        for i, r in enumerate(recommendations[:3], 1):
                            response += f"\n{i}. {r.get('description', 'N/A')}"
                    else:
                        response += "\n‚úÖ T√†i li·ªáu tu√¢n th·ªß t·ªët"
                    
                    response += f"\n\n**‚è±Ô∏è Th·ªùi gian:** {data.get('processing_time', 0):.1f}s"
                    response += f"\n*ü§ñ VPBank K-MULT Compliance Engine*"
                    
                    return response
                else:
                    return "‚ùå **L·ªói**: Kh√¥ng th·ªÉ x·ª≠ l√Ω t√†i li·ªáu"
                    
            except Exception as e:
                logger.error(f"üîß [COMPLIANCE_TOOL] Error: {e}")
                return f"‚ùå **L·ªói ki·ªÉm tra tu√¢n th·ªß**: {str(e)}"
        else:
            # Handle text-based queries using compliance node logic
            try:
                from app.mutil_agent.agents.conversation_agent.nodes.compliance_node import (
                    _determine_query_type,
                    _handle_regulation_query,
                    _handle_compliance_help,
                    _handle_general_compliance_chat
                )
                
                query_type = _determine_query_type(query)
                
                async def handle_query():
                    if query_type == "regulation_query":
                        return await _handle_regulation_query(query)
                    elif query_type == "compliance_help":
                        return await _handle_compliance_help(query)
                    else:
                        return await _handle_general_compliance_chat(query)
                
                try:
                    response = asyncio.run(handle_query())
                except RuntimeError as e:
                    if "cannot be called from a running event loop" in str(e):
                        import concurrent.futures
                        def run_in_thread():
                            return asyncio.run(handle_query())
                        with concurrent.futures.ThreadPoolExecutor() as executor:
                            future = executor.submit(run_in_thread)
                            response = future.result(timeout=15)
                    else:
                        raise e
                
                return response
                
            except Exception as e:
                logger.error(f"üîß [COMPLIANCE_TOOL] Node error: {e}")
                return f"‚ùå **L·ªói x·ª≠ l√Ω tu√¢n th·ªß**: {str(e)}"

    except Exception as e:
        logger.error(f"üîß [COMPLIANCE_TOOL] Tool error: {e}")
        return f"‚ùå **L·ªói ki·ªÉm tra tu√¢n th·ªß**: {str(e)}"


@tool
def text_summary_document_tool(query: str, file_data: Optional[Dict[str, Any]] = None) -> str:
    """
    Text summary document tool - wraps /text/summary/document endpoint
    Preserves EXACT logic from text_routes.py
    """
    try:
        logger.info(f"üìÑ [TEXT_SUMMARY_TOOL] Processing: {query[:100]}...")
        
        if file_data and file_data.get('raw_bytes'):
            # Import EXACT endpoint function
            from app.mutil_agent.routes.v1.text_routes import summarize_document
            
            try:
                # Create UploadFile object - EXACT same as endpoint expects
                file_obj = UploadFile(
                    filename=file_data.get('filename', 'document.pdf'),
                    file=io.BytesIO(file_data.get('raw_bytes')),
                    size=len(file_data.get('raw_bytes', b'')),
                    headers={"content-type": file_data.get('content_type', 'application/pdf')}
                )
                
                # Reset file pointer
                file_obj.file.seek(0)
                
                # Call EXACT endpoint function with EXACT parameters from endpoint
                async def call_endpoint():
                    return await summarize_document(
                        file=file_obj,
                        summary_type="general",  # Default from endpoint
                        max_length=300,         # Default from endpoint
                        language="vietnamese",   # Default from endpoint
                        max_pages=None          # Default from endpoint
                    )
                
                # Execute with proper async handling
                try:
                    result = asyncio.run(call_endpoint())
                except RuntimeError as e:
                    if "cannot be called from a running event loop" in str(e):
                        import concurrent.futures
                        def run_in_thread():
                            return asyncio.run(call_endpoint())
                        with concurrent.futures.ThreadPoolExecutor() as executor:
                            future = executor.submit(run_in_thread)
                            result = future.result(timeout=60)  # Longer timeout for large files
                    else:
                        raise e
                
                # Format response using EXACT endpoint result structure
                if result and isinstance(result, dict):
                    data = result
                    
                    response = f"""üìÑ **T√≥m t·∫Øt t√†i li·ªáu: {file_data.get('filename', 'Unknown')}**

**üìù N·ªôi dung t√≥m t·∫Øt:**
{data.get('summary', 'Kh√¥ng th·ªÉ t√≥m t·∫Øt')}

**üìä Th·ªëng k√™:**"""
                    
                    # Add statistics from endpoint response
                    if 'word_count' in data:
                        word_count = data['word_count']
                        response += f"\n‚Ä¢ **T·ª´ g·ªëc:** {word_count.get('original', 0):,} t·ª´"
                        response += f"\n‚Ä¢ **T·ª´ t√≥m t·∫Øt:** {word_count.get('summary', 0):,} t·ª´"
                    
                    if 'compression_ratio' in data:
                        response += f"\n‚Ä¢ **T·ª∑ l·ªá n√©n:** {data['compression_ratio']}"
                    
                    # Add document info from endpoint response
                    if 'document_info' in data:
                        doc_info = data['document_info']
                        if doc_info.get('pages'):
                            response += f"\n‚Ä¢ **S·ªë trang:** {doc_info['pages']}"
                        if doc_info.get('file_size'):
                            response += f"\n‚Ä¢ **K√≠ch th∆∞·ªõc:** {doc_info['file_size']:,} bytes"
                    
                    response += f"\n‚Ä¢ **Th·ªùi gian:** {data.get('processing_time', 0):.1f}s"
                    response += f"\n\n*ü§ñ VPBank K-MULT Text Intelligence*"
                    
                    return response
                else:
                    return f"‚ùå **L·ªói**: Kh√¥ng th·ªÉ t√≥m t·∫Øt file {file_data.get('filename', 'Unknown')}"
                    
            except Exception as e:
                logger.error(f"üìÑ [TEXT_SUMMARY_TOOL] Error: {e}")
                return f"‚ùå **L·ªói t√≥m t·∫Øt t√†i li·ªáu**: {str(e)}"
        else:
            # Handle text-based queries using text summary node logic
            try:
                from app.mutil_agent.agents.conversation_agent.nodes.text_summary_node import _extract_text_from_message
                from app.mutil_agent.services.text_service import TextSummaryService
                
                # Extract text using EXACT node logic
                text_to_summarize = _extract_text_from_message(query)
                
                if not text_to_summarize or len(text_to_summarize.strip()) < 10:
                    return """‚ùå **Kh√¥ng t√¨m th·∫•y vƒÉn b·∫£n ƒë·ªÉ t√≥m t·∫Øt**

**H∆∞·ªõng d·∫´n:**
‚Ä¢ G·ª≠i vƒÉn b·∫£n: "T√≥m t·∫Øt: [n·ªôi dung]"
‚Ä¢ Upload file: PDF, DOCX, TXT
‚Ä¢ Paste vƒÉn b·∫£n d√†i ƒë·ªÉ t√¥i t√≥m t·∫Øt"""
                
                # Use TextSummaryService with EXACT parameters
                text_service = TextSummaryService()
                
                async def summarize():
                    return await text_service.summarize_text(
                        text=text_to_summarize,
                        summary_type="general",
                        max_length=300,  # Same as endpoint default
                        language="vietnamese"
                    )
                
                try:
                    result = asyncio.run(summarize())
                except RuntimeError as e:
                    if "cannot be called from a running event loop" in str(e):
                        import concurrent.futures
                        def run_in_thread():
                            return asyncio.run(summarize())
                        with concurrent.futures.ThreadPoolExecutor() as executor:
                            future = executor.submit(run_in_thread)
                            result = future.result(timeout=30)
                    else:
                        raise e
                
                # Format response
                if result and 'summary' in result:
                    response = f"""üìÑ **T√≥m t·∫Øt vƒÉn b·∫£n:**

**üìù N·ªôi dung:**
{result['summary']}

**üìä Th·ªëng k√™:**"""
                    
                    if 'word_count' in result:
                        word_count = result['word_count']
                        response += f"\n‚Ä¢ **T·ª´ g·ªëc:** {word_count['original']:,} t·ª´"
                        response += f"\n‚Ä¢ **T·ª´ t√≥m t·∫Øt:** {word_count['summary']:,} t·ª´"
                    
                    if 'compression_ratio' in result:
                        response += f"\n‚Ä¢ **T·ª∑ l·ªá n√©n:** {result['compression_ratio']}"
                    
                    response += f"\n\n*ü§ñ VPBank K-MULT Text Intelligence*"
                    return response
                else:
                    return "‚ùå **L·ªói**: Kh√¥ng th·ªÉ t·∫°o t√≥m t·∫Øt"
                
            except Exception as e:
                logger.error(f"üìÑ [TEXT_SUMMARY_TOOL] Node error: {e}")
                return f"‚ùå **L·ªói t√≥m t·∫Øt vƒÉn b·∫£n**: {str(e)}"

    except Exception as e:
        logger.error(f"üìÑ [TEXT_SUMMARY_TOOL] Tool error: {e}")
        return f"‚ùå **L·ªói x·ª≠ l√Ω t√≥m t·∫Øt**: {str(e)}"


@tool
def risk_assessment_tool(query: str, file_data: Optional[Dict[str, Any]] = None) -> str:
    """
    Risk assessment tool - wraps /risk/assess endpoint
    Preserves EXACT logic from risk_routes.py
    """
    try:
        logger.info(f"üîß [RISK_TOOL] Processing: {query[:100]}...")
        
        # Import required models and services
        from app.mutil_agent.models.risk import RiskAssessmentRequest
        from app.mutil_agent.routes.v1.risk_routes import assess_risk_endpoint, assess_risk_file_endpoint
        from fastapi import UploadFile
        import io
        
        # Extract basic risk data from query
        financial_data = _extract_risk_data_from_query(query)
        
        # Extract text from file if provided
        if file_data and file_data.get('raw_bytes'):
            logger.info(f"üîß [RISK_TOOL] Processing file: {file_data.get('filename')} ({len(file_data.get('raw_bytes', b''))} bytes)")
            
            try:
                # Extract text from file
                file_text = extract_text_from_file(file_data)
                financial_data['financial_documents'] = file_text
                logger.info(f"üîß [RISK_TOOL] Extracted {len(file_text)} characters from file")
                
                if not file_text.strip():
                    logger.warning("üîß [RISK_TOOL] No text extracted from file, proceeding with basic data")
                
            except Exception as file_error:
                logger.error(f"üîß [RISK_TOOL] File processing error: {file_error}")
                return f"‚ùå **L·ªói x·ª≠ l√Ω file**: {str(file_error)}"
        
        # Handle risk assessment with file content
        async def call_endpoint():
            # Create RiskAssessmentRequest object v·ªõi file content
            risk_request = RiskAssessmentRequest(
                entity_id=f"entity_{uuid4().hex[:8]}",
                entity_type="doanh nghi·ªáp",
                financials=financial_data.get('financials', {}),
                market_data=financial_data.get('market_data', {}),
                custom_factors=financial_data.get('custom_factors', {}),
                applicant_name=financial_data.get('applicant_name', 'Kh√°ch h√†ng'),
                business_type=financial_data.get('business_type', 'general'),
                requested_amount=financial_data.get('requested_amount', 1000000000),
                currency=financial_data.get('currency', 'VND'),
                loan_term=financial_data.get('loan_term', 12),
                loan_purpose=financial_data.get('loan_purpose', 'Kinh doanh'),
                assessment_type="comprehensive",
                collateral_type=financial_data.get('collateral_type', 'Kh√¥ng t√†i s·∫£n ƒë·∫£m b·∫£o'),
                financial_documents=financial_data.get('financial_documents', '')  # ‚úÖ Th√™m file content
            )
            
            return await assess_risk_endpoint(risk_request)
            
            # Execute with proper async handling
            try:
                result = asyncio.run(call_endpoint())
            except RuntimeError as e:
                if "cannot be called from a running event loop" in str(e):
                    import concurrent.futures
                    def run_in_thread():
                        return asyncio.run(call_endpoint())
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(run_in_thread)
                        result = future.result(timeout=30)
                else:
                    raise e
            
            logger.info("üîß [RISK_TOOL] Successfully processed text with DIRECT endpoint call")
        
        # Format response using EXACT endpoint result structure
        if result and isinstance(result, dict):
            data = result.get('data', {})
            
            response = f"""üìä **Ph√¢n t√≠ch r·ªßi ro - VPBank K-MULT**

**Th√¥ng tin ƒë√°nh gi√°:**
‚Ä¢ **T√™n:** {financial_data.get('applicant_name', 'Ch∆∞a x√°c ƒë·ªãnh')}
‚Ä¢ **S·ªë ti·ªÅn:** {financial_data.get('requested_amount', 0):,} {financial_data.get('currency', 'VND')}
‚Ä¢ **Lo·∫°i h√¨nh:** {financial_data.get('business_type', 'Ch∆∞a x√°c ƒë·ªãnh')}

**K·∫øt qu·∫£ ph√¢n t√≠ch:**
‚Ä¢ **ƒêi·ªÉm r·ªßi ro:** {data.get('risk_score', 'N/A')}
‚Ä¢ **M·ª©c ƒë·ªô r·ªßi ro:** {data.get('risk_level', 'N/A')}
‚Ä¢ **ƒêi·ªÉm t√≠n d·ª•ng:** {data.get('credit_score', 'N/A')}

**Khuy·∫øn ngh·ªã:**
{data.get('recommendations', ['C·∫ßn ƒë√°nh gi√° th√™m'])[0] if data.get('recommendations') else 'C·∫ßn ƒë√°nh gi√° th√™m'}

**B√°o c√°o AI:**
{data.get('ai_report', 'ƒêang ph√¢n t√≠ch d·ªØ li·ªáu t√†i ch√≠nh v√† ƒë√°nh gi√° r·ªßi ro...')}

**Th·ªùi gian x·ª≠ l√Ω:** {data.get('processing_time', 0):.1f}s

---

*ü§ñ VPBank K-MULT Agent Studio*
*‚è∞ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}*"""
        else:
            response = f"""üìä **Ph√¢n t√≠ch r·ªßi ro - VPBank K-MULT**

**Y√™u c·∫ßu:** {query[:200]}...

**Ph√¢n t√≠ch s∆° b·ªô:**
- ƒêang x·ª≠ l√Ω d·ªØ li·ªáu t√†i ch√≠nh
- √Åp d·ª•ng m√¥ h√¨nh ƒë√°nh gi√° r·ªßi ro VPBank  
- Tu√¢n th·ªß Basel III v√† quy ƒë·ªãnh SBV

**L∆∞u √Ω:** ƒê·ªÉ c√≥ k·∫øt qu·∫£ ch√≠nh x√°c, vui l√≤ng cung c·∫•p:
‚Ä¢ T√™n kh√°ch h√†ng/doanh nghi·ªáp
‚Ä¢ S·ªë ti·ªÅn vay mong mu·ªën
‚Ä¢ M·ª•c ƒë√≠ch vay v·ªën
‚Ä¢ Th√¥ng tin t√†i ch√≠nh

---

*ü§ñ VPBank K-MULT Agent Studio*
*‚è∞ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}*"""
        
        logger.info("üîß [RISK_TOOL] Successfully processed with DIRECT endpoint wrapper")
        return response
        
    except Exception as e:
        logger.error(f"üîß [RISK_TOOL] Tool error: {str(e)}")
        return f"‚ùå **L·ªói ph√¢n t√≠ch r·ªßi ro**: {str(e)}"


def extract_text_from_file(file_data: Dict[str, Any]) -> str:
    """Extract text from uploaded file"""
    try:
        raw_bytes = file_data.get('raw_bytes')
        content_type = file_data.get('content_type', '')
        
        if content_type == "application/pdf":
            from app.mutil_agent.helpers.improved_pdf_extractor import ImprovedPDFExtractor
            extractor = ImprovedPDFExtractor()
            result = extractor.extract_text_from_pdf(raw_bytes)
            return result.get('text', '').strip()
        elif content_type in ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]:
            import docx
            import io
            doc = docx.Document(io.BytesIO(raw_bytes))
            return "\n".join([paragraph.text for paragraph in doc.paragraphs])
        elif content_type.startswith("text/"):
            return raw_bytes.decode('utf-8')
        else:
            return ""
    except Exception as e:
        logger.error(f"Error extracting text from file: {e}")
        return ""

def _extract_risk_data_from_query(query: str) -> Dict[str, Any]:
    """Extract basic risk data from query - helper function"""
    import re
    
    financial_data = {
        'applicant_name': 'Kh√°ch h√†ng',
        'requested_amount': 1000000000,
        'business_type': 'general',
        'currency': 'VND',
        'loan_term': 12,
        'loan_purpose': 'Kinh doanh',
        'collateral_type': 'Kh√¥ng t√†i s·∫£n ƒë·∫£m b·∫£o',
        # Required fields with proper structure
        'financials': {
            'revenue': 1000000000,
            'profit': 100000000,
            'assets': 2000000000,
            'liabilities': 500000000,
            'cash_flow': 300000000
        },
        'market_data': {
            'industry': 'general',
            'market_condition': 'stable',
            'competition_level': 'medium',
            'growth_potential': 'moderate'
        },
        'custom_factors': {
            'risk_tolerance': 'medium',
            'business_experience': 'established',
            'market_position': 'stable'
        }
    }
    
    try:
        # Extract amount (t·ª∑, tri·ªáu, etc.)
        amount_patterns = [
            r'(\d+(?:\.\d+)?)\s*t·ª∑',
            r'(\d+(?:\.\d+)?)\s*tri·ªáu',
            r'(\d+(?:,\d+)*)\s*VN[Dƒê]',
            r'(\d+(?:,\d+)*)\s*ƒë·ªìng'
        ]
        
        for pattern in amount_patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                amount_str = match.group(1).replace(',', '')
                amount = float(amount_str)
                if 't·ª∑' in match.group(0):
                    amount *= 1000000000
                elif 'tri·ªáu' in match.group(0):
                    amount *= 1000000
                financial_data['requested_amount'] = int(amount)
                break
        
        # Extract company name
        company_patterns = [
            r'c√¥ng ty\s+([A-Za-z0-9\s]+)',
            r'doanh nghi·ªáp\s+([A-Za-z0-9\s]+)',
            r'cho\s+([A-Za-z0-9\s]+)'
        ]
        
        for pattern in company_patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                financial_data['applicant_name'] = match.group(1).strip()
                break
        
    except Exception as e:
        logger.error(f"Error extracting risk data: {e}")
    
    return financial_data
